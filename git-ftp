#!/usr/bin/env bash
#
# Copyright 2010-2014 Ren√© Moser
# http://github.com/git-ftp/git-ftp
#
# Git-ftp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Git-ftp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Git-ftp.  If not, see <http://www.gnu.org/licenses/>.

# ------------------------------------------------------------
# Setup Environment
# ------------------------------------------------------------

# General config
readonly DEFAULT_PROTOCOL="ftp"
readonly REMOTE_LCK_FILE="$(basename "$0").lck"
readonly SYSTEM="$(uname)"
readonly VERSION='1.1.0-develop'

# ------------------------------------------------------------
# Defaults
# ------------------------------------------------------------
URL=""
NEW_REPO=""
COMMIT_MESSAGE=""
REMOTE_PROTOCOL=""
REMOTE_HOST=""
REMOTE_USER=""
REMOTE_PASSWD=""
REMOTE_ROOT=""
REMOTE_PATH=""
REMOTE_CACERT=""
REMOTE_DELETE_CMD="-*DELE "
REMOTE_CMD_OPTIONS="-s"
LFTP_OPTIONS=""
ACTION=""
LOG_CACHE=""
ERROR_LOG=""
SCOPE=""
KEYCHAIN_USER=""
KEYCHAIN_HOST=""
DEPLOYED_SHA1_FILE=".git-ftp.log"
DEPLOYED_SHA1=""
LOCAL_SHA1=""
SYNCROOT=""
COMMIT_ARGS=" --no-edit"
CURL_INSECURE=""
CURL_PUBLIC_KEY=""
CURL_PRIVATE_KEY=""
CURL_UPLOADS=()
CURL_DELETE=()
CURL_DISABLE_EPSV=0
declare -a CURL_ARGS
declare -i VERBOSE=0
declare -i IGNORE_DEPLOYED=0
declare -i DRY_RUN=0
declare -i FORCE=0
declare -i ENABLE_REMOTE_LCK=0
declare -i ACTIVE_MODE=0
declare -i USE_KEYCHAIN=0
declare -i ARG_MAX=4096
declare -a GIT_SUBMODULES
declare -i INTERACTIVE=0
declare -i CHECK_FOR_REMOTE_CHANGES=1

# ------------------------------------------------------------
# Constant Exit Error Codes
# ------------------------------------------------------------
readonly ERROR_USAGE=2
readonly ERROR_MISSING_ARGUMENTS=3
readonly ERROR_UPLOAD=4
readonly ERROR_DOWNLOAD=5
readonly ERROR_UNKNOWN_PROTOCOL=6
readonly ERROR_REMOTE_LOCKED=7
readonly ERROR_GIT=8
readonly ERROR_DEPENDENCY=9
readonly ERROR_SYNC=10

# ------------------------------------------------------------
# Functions
# ------------------------------------------------------------

usage_long()
{
local pager=$(git config --get core.pager)
${GIT_PAGER:-${pager:-${PAGER:-less -FRSX}}} << EOF
USAGE
	git-ftp <action> [<options>] <url>


DESCRIPTION
	git-ftp does FTP the Git way.

	It uses Git to determine which local files have changed since the last
	deployment to the remote server and saves you time and bandwidth by
	uploading only those files.

	It keeps track of the deployed state by uploading the SHA1 of the last
	deployed commit in a log file.

	It downloads remote changes and merges them into your working copy.

ACTIONS
	. init
		Does an initial upload of the latest version of all non-ignored
		git-tracked files to the remote server and creates .git-ftp.log
		file containing the SHA1 of the latest commit.

	. push
		Uploads git-tracked files which have changed since last upload.

	. pull
		Downloads changes from the remote server into a separate commit
		and merges them into your current branch.

	. show
		Downloads last uploaded SHA1 from log and hooks \`git show\`.

	. log
		Downloads last uploaded SHA1 from log and hooks \`git log\`.

	. catchup
		Uploads current SHA1 to log, does not upload any files.

		This is useful if you used another FTP client to upload the
		files and now want to remember the SHA1.

	. bootstrap
		Creates a new git repository populated with the contents of
		a remote tree.

	. download
		Downloads changes from the remote host into your working tree.

		But probably you want to use pull.
	
	. add-scope
		Add a scope (e.g. dev, production, testing).

	. remove-scope
		Completely remove a scope.

	. help
		Shows this help screen.


URL
	. FTP (default)		host.example.com[:<port>][/<remote path>]
	. FTP			ftp://host.example.com[:<port>][/<remote path>]
	. SFTP			sftp://host.example.com[:<port>][/<remote path>]
	. FTPS			ftps://host.example.com[:<port>][/<remote path>]
	. FTPES			ftpes://host.example.com[:<port>][/<remote path>]


OPTIONS
	-h, --help		Shows this help screen.
	-u, --user		FTP login name.
	-p, --passwd		FTP password.
	-k, --keychain		FTP password from KeyChain (Mac OS X only).
	-s, --scope		Using a scope (e.g. dev, production, testing).
	-D, --dry-run		Dry run: Does not upload anything.
	-a, --all		Uploads all files, ignores deployed SHA1 hash.
	-c, --commit		Sets SHA1 hash of last deployed commit by option.
	-A, --active		Use FTP active mode.
	-l, --lock		Enable/Disable remote locking.
	-f, --force		Force, does not ask questions.
	-n, --silent		Silent mode.
	-v, --verbose		Verbose mode.
	-vv			Very verbose or debug mode.
	--remote-root		Specifies remote root directory
	--syncroot		Specifies a local directory to sync from as if it were the git project root path.
	--insecure		Don't verify server's certificate.
	--cacert		Specify a <file> as CA certificate store. Useful when a server has got a self-signed certificate.
	--no-commit		Perform the merge at the and of pull but do not autocommit, to have the chance to inspect and further tweak the merge result before committing.
	--interactive		Asks what to do if untracked changes on the remote server are found.
	--ignore-remote-changes	Disable check for changes on the remote server before uploading.
	--disable-epsv		Tell curl to disable the use of the EPSV command when doing passive FTP transfers. Curl will normally always first attempt to use EPSV before PASV, but with this option, it will not try using EPSV.
	--version		Prints version.


EXAMPLES
	. git-ftp push -u john ftp://ftp.example.com:4445/public_ftp -p -v
	. git-ftp push -p -u john -v ftp.example.com:4445:/public_ftp
	. git-ftp add-scope production ftp://user:secr3t@ftp.example.com:4445/public_ftp
	. git-ftp push --scope production
	. git-ftp remove-scope production


SET DEFAULTS
	. git config git-ftp.user john
	. git config git-ftp.url ftp.example.com
	. git config git-ftp.password secr3t
	. git config git-ftp.remote-root "~/www/"
	. git config git-ftp.syncroot path/dir
	. git config git-ftp.cacert path/cacert
	. git config git-ftp.deployedsha1file mySHA1File
	. git config git-ftp.insecure 1


SET SCOPE DEFAULTS 
	e.g. your scope is 'testing'
	. git config git-ftp.testing.url ftp.example.local


VERSION
	$VERSION
EOF
exit 0
}

usage() {
	echo "git-ftp <action> [<options>] <url>"
	exit $ERROR_USAGE
}

escape() {
	echo "$1" | sed 's/\([\.\+\$]\)/\\\1/g'
}

has() {
	local item=$1; shift
	echo " $@ " | grep -q " $(escape $item) "
}

cache_git_submodules() {
	GIT_SUBMODULES=$(git submodule | awk '{print $2}')
}

is_submodule() {
	has $1 ${GIT_SUBMODULES[@]}
}

is_arg_max_reached() {
	local ARGS=("$@")
	ARGS_STRING=$(echo ${ARGS[@]})
	CURRENT_LENGTH=$(( ${#ARGS_STRING} ))
	if [ $CURRENT_LENGTH -lt $ARG_MAX ]; then
		return 1
	fi
	return 0
}

ask_for_passwd() {
	echo -n "Password: "
	stty -echo > /dev/null 2>&1
	read REMOTE_PASSWD
	stty echo > /dev/null 2>&1
	echo ""
}

get_keychain_password () {
	if [ "$SYSTEM" = "Darwin" ]; then
		# Split user and host if necessary
		if [ $(echo "$KEYCHAIN_USER" | grep '@') ]; then
			KEYCHAIN_HOST=$(echo "$KEYCHAIN_USER" | cut -d '@' -f2)
			KEYCHAIN_USER=$(echo "$KEYCHAIN_USER" | cut -d '@' -f1)
		else
			[ -z $KEYCHAIN_USER ] && KEYCHAIN_USER=$REMOTE_USER
			[ -z $KEYCHAIN_HOST ] && KEYCHAIN_HOST=$REMOTE_HOST
		fi

		[ -z $KEYCHAIN_USER ] && print_error_and_die "Missing keychain account." $ERROR_MISSING_ARGUMENTS
		CURL_ARGS=(-a "$KEYCHAIN_USER")
		[ -n "$KEYCHAIN_HOST" ] && CURL_ARGS+=(-s "$KEYCHAIN_HOST")

		local pass
		if pass="$(security find-internet-password ${CURL_ARGS[@]} -g 2>&1 > /dev/null)"; then
			without_prefix="${pass#password: \"}"
			REMOTE_PASSWD="${without_prefix%\"}"
		else
			print_error_and_die "Password not found in keychain for account '$KEYCHAIN_USER @ $KEYCHAIN_HOST'." $ERROR_MISSING_ARGUMENTS
		fi
	else
		write_log "Ingoring -k on non-Darwin systems."
	fi
}

# Checks if last comand was successful
check_exit_status() {
	if [ $? -ne 0 ]; then
		print_error_and_die "$1, exiting..." $2
	fi
}

get_config() {
	# try .git-ftp-config
	[ -n "$SCOPE" ] && [ -f '.git-ftp-config' ] && OUT="$(git config -f '.git-ftp-config' --get git-ftp.$SCOPE.$1)"
	if [ $? -eq 0 ];
	then
		echo $OUT
		return 0
	fi
	[ -f '.git-ftp-config' ] && OUT="$(git config -f '.git-ftp-config' --get git-ftp.$1)"
	if [ $? -eq 0 ];
	then
		echo $OUT
		return 0
	fi
	[ -n "$SCOPE" ] && OUT="$(git config --get git-ftp.$SCOPE.$1)"
	if [ $? -eq 0 ];
	then
		echo $OUT
		return 0
	fi
	OUT="$(git config --get git-ftp.$1)"
	if [ $? -eq 0 ];
	then
		echo $OUT
		return 0
	fi
	[ -n $2 ] && OUT=$2
	echo $OUT
}

set_deployed_sha1_file() {
	DEPLOYED_SHA1_FILE="$(get_config deployedsha1file .git-ftp.log)"
}

# Simple log func
write_log() {
	if [ $VERBOSE -eq 1 ]; then
		echo "$(date): $1"
	else
		if [ -n "$LOG_CACHE" ]; then
			LOG_CACHE="$LOG_CACHE\n$(date): $1"
		else
			LOG_CACHE="$(date): $1"
		fi
	fi
}

write_error_log() {
	write_log $1
	if [ -n "$ERROR_LOG" ]; then
		ERROR_LOG="$ERROR_LOG\n: $1"
	else
		ERROR_LOG="$1"
	fi
}

print_error_log() {
	if [ -n "$ERROR_LOG" ]; then
		echo "Error log:"
		echo $ERROR_LOG
	fi
}

# Simple error printer
print_error_and_die() {
	if [ $VERBOSE -eq 0 ]; then
		echo "fatal: $1" >&2
	else
		write_log "fatal: $1"
	fi
	exit $2
}

# Simple info printer
print_info() {
	if [ $VERBOSE -eq 0 ]; then
		echo "$1"
	else
		write_log "$1"
	fi
}

set_default_curl_options() {
	OIFS="$IFS"
	IFS=" "
	CURL_ARGS=(${REMOTE_CMD_OPTIONS[@]})
	IFS="$OIFS"
	CURL_ARGS+=(--globoff)
	if [ ! -z $REMOTE_USER ]; then
		CURL_ARGS+=(--user "$REMOTE_USER":"$REMOTE_PASSWD")
	else
		CURL_ARGS+=(--netrc)
	fi
	CURL_ARGS+=(-#)
	if [ $ACTIVE_MODE -eq 1 ]; then
		CURL_ARGS+=(-P "-")
	else
		if [ $CURL_DISABLE_EPSV -eq 1 ]; then
			CURL_ARGS+=(--disable-epsv)
		fi
	fi
}

upload_get_dest_file() {
	local DEST_FILE="$1"

	if [ -n "$SYNCROOT" ]; then
		DEST_FILE=${DEST_FILE/$SYNCROOT/$REPLACE}
	fi

	echo $DEST_FILE
}

upload_file() {
	local SRC_FILE="$1"
	local DEST_FILE="$2"

	if [ -z $DEST_FILE ]; then
		DEST_FILE=$(upload_get_dest_file $SRC_FILE)
	fi

	set_default_curl_options
	CURL_ARGS+=(-T "$SRC_FILE")
	CURL_ARGS+=(--ftp-create-dirs)
	CURL_ARGS+=("$REMOTE_PROTOCOL://$REMOTE_HOST/${REMOTE_PATH}${DEST_FILE}")
	curl "${CURL_ARGS[@]}"
	check_exit_status "Could not upload file: '${REMOTE_PATH}$DEST_FILE'." $ERROR_UPLOAD
}

grep_quote() {
    sed 's/[]\.|$(){}?+*^]/\\&/g' <<< "$*"
}

# @returns int Whether remote file has newer date (0) or not (1)
remote_file_modified() {
	local SRC_FILE="$1"
	local DEST_FILE="$2"
	local DEST_FILE_LAST_MODIFIED=$(get_file_lastmodified "$DEST_FILE")
	if [ -z "$DEST_FILE_LAST_MODIFIED" ]; then
		write_log "No date for remote file $DEST_FILE found."
		return 1
	fi
	if [ -z "$DEPLOYED_SHA1_LAST_MODIFIED" ]; then
		write_log "No date of previous commit found. Remote file $DEST_FILE is newer than null."
		return 0
	fi
	if [ "$DEST_FILE_LAST_MODIFIED" -gt "$DEPLOYED_SHA1_LAST_MODIFIED" ]; then
		write_log "Remote file $DEST_FILE has newer modification date (at $(format_date $DEST_FILE_LAST_MODIFIED)), maybe it was changed outside git?"
		return 0
	fi
	write_log "Remote file $DEST_FILE not touched."
	return 1
}

# @returns int Whether handling this file (0) or not (1)
shall_overwrite_file() {
	local SRC_FILE="$1"
	local DEST_FILE="$2"
	while :; do
		echo -e -n "$SRC_FILE has remote changes that have not been committed yet.\n (O)verwrite, (D)ownload to working copy, (S)kip this time or (N)ever upload this file? "
		read ANSWER
		if [ "$ANSWER" == 'O' ] || [ "$ANSWER" == 'o' ]; then 
			print_info "Overwriting $SRC_FILE..."
			return 0
		elif [ "$ANSWER" == 'D' ] || [ "$ANSWER" == 'd' ]; then 
			print_info "Downloading $SRC_FILE..."
			get_file_content "$DEST_FILE" > "$SRC_FILE"
			return 1
		elif [ "$ANSWER" == 'S' ] || [ "$ANSWER" == 's' ]; then 
			print_info "Skipping $SRC_FILE..."
			return 1
		elif [ "$ANSWER" == 'N' ] || [ "$ANSWER" == 'n' ]; then
			echo $(grep_quote $SRC_FILE) >> .git-ftp-ignore
			print_info "Added $SRC_FILE to .git-ftp-ignore."
			return 1
		fi
	done
}

set_upload_curl_arguments() {
	set_default_curl_options
	CURL_ARGS+=(--ftp-create-dirs)
	CURL_ARGS+=("${CURL_UPLOADS[@]}")
}

upload_file_buffered() {
	local SRC_FILE="$1"
	local DEST_FILE="$2"
	local ADD_ARGS=()

	if [ -z $DEST_FILE ]; then
		DEST_FILE=$(upload_get_dest_file $SRC_FILE)
	fi

	if [ -n "$SYNCROOT" ]; then
		DEST_FILE=${DEST_FILE/$SYNCROOT/$REPLACE}
	fi

	ADD_ARGS+=(-T "./$SRC_FILE")
	ADD_ARGS+=("$REMOTE_PROTOCOL://$REMOTE_HOST/${REMOTE_PATH}${DEST_FILE}")
	set_upload_curl_arguments
	if is_arg_max_reached "${CURL_ARGS[@]}" "${ADD_ARGS[@]}"; then
		IFS="$OIFS"
		fire_upload_buffer
		IFS="$NIFS"
	fi

	CURL_UPLOADS+=("${ADD_ARGS[@]}")
}

fire_upload_buffer() {
	if [ -z "$CURL_UPLOADS" ]; then
		return 0
	fi
	print_info "Uploading ..."
	set_upload_curl_arguments
	curl "${CURL_ARGS[@]}"
	check_exit_status "Could not upload files." $ERROR_UPLOAD
	CURL_UPLOADS=()
}

delete_file() {
	local FILENAME="$1"
	set_default_curl_options
	CURL_ARGS+=(-Q "${REMOTE_DELETE_CMD}${REMOTE_PATH}${FILENAME}")
	CURL_ARGS+=("$REMOTE_PROTOCOL://$REMOTE_HOST")
	if [ "${REMOTE_CMD_OPTIONS:0:2}" = "-v" ]; then
		curl "${CURL_ARGS[@]}"
	else
		curl "${CURL_ARGS[@]}" > /dev/null 2>&1
	fi
	if [ $? -ne 0 ]; then
		write_error_log "Could not delete ${REMOTE_PATH}${FILENAME}, continuing..."
	fi
}

set_delete_curl_arguments() {
	set_default_curl_options
	CURL_ARGS+=("${CURL_DELETE[@]}")
	CURL_ARGS+=("$REMOTE_PROTOCOL://$REMOTE_HOST")
}

delete_file_buffered() {
	local FILENAME="$1"
	local ADD_ARGS=()
	ADD_ARGS+=(-Q "${REMOTE_DELETE_CMD}${REMOTE_PATH}${FILENAME}")
	set_delete_curl_arguments
	if is_arg_max_reached "${CURL_ARGS[@]}" "${ADD_ARGS[@]}"; then
		IFS="$OIFS"
		fire_delete_buffer
		IFS="$NIFS"
	fi
	CURL_DELETE+=("${ADD_ARGS[@]}")
}

fire_delete_buffer() {
	if [ -z "$CURL_DELETE" ]; then
		return 0
	fi
	print_info "Deleting ..."
	set_delete_curl_arguments
	if [ "${REMOTE_CMD_OPTIONS:0:2}" = "-v" ]; then
		curl "${CURL_ARGS[@]}"
	else
		curl "${CURL_ARGS[@]}" > /dev/null 2>&1
	fi
	if [ $? -ne 0 ]; then
		write_error_log "Some files and/or folders could not be deleted."
	fi
	CURL_DELETE=()
}

delete_dir() {
	ORIGIN_REMOTE_DELETE_CMD=$REMOTE_DELETE_CMD
	REMOTE_DELETE_CMD="-*RMD "
	delete_file_buffered $1
	REMOTE_DELETE_CMD=$ORIGIN_REMOTE_DELETE_CMD
}

get_file_content() {
	local SRC_FILE="$1"
	set_default_curl_options
	CURL_ARGS+=("$REMOTE_PROTOCOL://$REMOTE_HOST/${REMOTE_PATH}${SRC_FILE}")
	curl "${CURL_ARGS[@]}"
}

get_file_lastmodified() {
	local SRC_FILE="$1"
	set_default_curl_options
	CURL_ARGS+=("--head")
	CURL_ARGS+=("$REMOTE_PROTOCOL://$REMOTE_HOST/${REMOTE_PATH}${SRC_FILE}")

	local HEAD=''
	HEAD=$(curl "${CURL_ARGS[@]}")
	if [ $? -ne 0 ]; then
		return
	fi
	local GMT_TIME=$(echo "$HEAD" | grep -e "Last-Modified:" | cut -d ' ' -f 2-)
	if [ -z "$GMT_TIME" ]; then
		return
	fi
	date --date="$GMT_TIME" +"%s"
}

format_date()
{
	local UNIX_TIME="$1"

	# Format according to local timezone settings
	date --date="@$UNIX_TIME"
}

set_local_sha1() {
	LOCAL_SHA1=$(git log -n 1 --pretty=format:%H)
}

upload_local_sha1() {
	DEPLOYED_SHA1=$LOCAL_SHA1
	write_log "Uploading commit log to $REMOTE_PROTOCOL://$REMOTE_HOST/${REMOTE_PATH}$DEPLOYED_SHA1_FILE."
	if [ $DRY_RUN -ne 1 ]; then
		echo "$DEPLOYED_SHA1" | upload_file - $DEPLOYED_SHA1_FILE
		check_exit_status "Could not upload." $ERROR_UPLOAD
	fi
	print_info "Last deployment changed to $DEPLOYED_SHA1.";
}

remote_lock() {
	[ $ENABLE_REMOTE_LCK -ne 1 ] && return
	[ $FORCE -ne 1 ] && check_remote_lock

	local LCK_MESSAGE="${USER}@$(hostname --fqdn) on $(date --utc --rfc-2822)"

	write_log "Remote locking $LCK_MESSAGE."
	if [ $DRY_RUN -ne 1 ]; then
		echo "${LOCAL_SHA1}\n${LCK_MESSAGE}" | upload_file - $REMOTE_LCK_FILE
		check_exit_status "Could not upload remote lock file." $ERROR_UPLOAD
	fi
}

release_remote_lock() {
	[ $ENABLE_REMOTE_LCK != 1 ] && return;
	write_log "Releasing remote lock."
	delete_file $REMOTE_LCK_FILE
}

set_remote_host() {
	[ -z $URL ] && URL="$(get_config url)"
	REMOTE_HOST=$(expr "$URL" : ".*://\([[:alpha:]0-9\.:-]*\).*")
	[ -z $REMOTE_HOST ] && REMOTE_HOST=$(expr "$URL" : "\([[:alpha:]0-9\.:-]*\).*")
	[ -z $REMOTE_HOST ] && print_error_and_die "Remote host not set." $ERROR_MISSING_ARGUMENTS
}

set_remote_protocol() {
	# Split protocol from url
	REMOTE_PROTOCOL=$(get_protocol_of_url "$URL")

	# Protocol found?
	if [ ! -z $REMOTE_PROTOCOL ]; then
		REMOTE_PATH=$(echo "$URL" | cut -d '/' -f 4-)
		handle_remote_protocol_options
		return
	fi

	# Check if a unknown protocol is set, handle it or use default protocol
	local UNKNOWN_PROTOCOL=$(expr "$URL" : "\(.*:[/]*\).*")
	if [ -z $UNKNOWN_PROTOCOL ]; then
		write_log "Protocol not set, using default protocol $DEFAULT_PROTOCOL://."
		REMOTE_PROTOCOL=$DEFAULT_PROTOCOL
		echo "$URL" | egrep -q "/" && REMOTE_PATH=$(echo "$URL" | cut -d '/' -f 2-)
		handle_remote_protocol_options
		return
	fi
	print_error_and_die "Protocol unknown '$UNKNOWN_PROTOCOL'." $ERROR_UNKNOWN_PROTOCOL
}

set_remote_path() {
	# Check remote root directory
	[ -z $REMOTE_ROOT ] && REMOTE_ROOT="$(get_config remote-root)"
	if [ ! -z $REMOTE_ROOT ]; then
		! echo "$REMOTE_ROOT" | egrep -q "/$" && REMOTE_ROOT="$REMOTE_ROOT/"
		REMOTE_PATH="$REMOTE_ROOT$REMOTE_PATH"
	fi

	# Add trailing slash if missing
	if [ ! -z $REMOTE_PATH ] && ! echo "$REMOTE_PATH" | egrep -q "/$"; then
		write_log "Added missing trailing / in path."
		REMOTE_PATH="$REMOTE_PATH/"
	fi
}

set_deployed_sha1() {
	# Return if commit is set by user interaction using --commit
	if [ -n "$DEPLOYED_SHA1" ]; then
		return
	fi
	# Get the last commit (SHA) we deployed if not ignored or not found
	write_log "Retrieving last commit from $REMOTE_PROTOCOL://$REMOTE_HOST/$REMOTE_PATH."
	DEPLOYED_SHA1="$(get_file_content $DEPLOYED_SHA1_FILE)"
	check_exit_status "Could not get last commit. Network down? Wrong URL? Use 'git ftp init' for the initial push." $ERROR_DOWNLOAD
	write_log "Last deployed SHA1 for $REMOTE_HOST/$REMOTE_PATH is $DEPLOYED_SHA1."

	DEPLOYED_SHA1_LAST_MODIFIED="$(get_file_lastmodified $DEPLOYED_SHA1_FILE)"
	if [ -z "$DEPLOYED_SHA1_LAST_MODIFIED" ] || [ "$DEPLOYED_SHA1_LAST_MODIFIED" -lt 100 ]; then
		write_log "Last modified date of $DEPLOYED_SHA1_FILE could not be determined."
	else
		write_log "$DEPLOYED_SHA1 last modified at $(format_date $DEPLOYED_SHA1_LAST_MODIFIED) (server time)."
	fi
}

set_changed_files() {
	# Get raw list of files
	if [ $IGNORE_DEPLOYED -ne 0 ]; then
		git ls-files -t $SYNCROOT > '.git-ftp-tmp'
	else
		git diff --name-status --no-renames $DEPLOYED_SHA1 $SYNCROOT 2>/dev/null > '.git-ftp-tmp'
		local git_diff_status=$?
	fi

	# Add files from include file
	if [ -f '.git-ftp-include' ]; then
		grep -v '^#.*$\|^\s*$' '.git-ftp-include' | tr -d '\r' > '.git-ftp-include-tmp'

		grep '^!' '.git-ftp-include-tmp' | while read LINE
		do
			FILE_STATUS='M'
			FILE_PAIR=$(echo "$LINE" | sed 's/^!//')
			echo "$FILE_STATUS	$FILE_PAIR" >> '.git-ftp-tmp'
		done

		grep ':' '.git-ftp-include-tmp' | while read LINE
		do
			OIFS="$IFS"
			IFS=":"
			FILE_PAIR=($LINE)
			IFS="$OIFS"
			cat .git-ftp-tmp | tr '\t' ' ' | cut -f2- -d ' ' > .git-ftp-tmp-files
			if [[ $(grep -Fx "${FILE_PAIR[1]}" '.git-ftp-tmp-files') && ! $(grep -Fx "${FILE_PAIR[0]}" '.git-ftp-tmp-files') ]]; then
				DELETE_COUNT=0
				MODIFY_COUNT=0

				for SUB_LINE in $(grep -F "${FILE_PAIR[0]}" '.git-ftp-include-tmp')
				do
					OIFS="$IFS"
					IFS=":"
					SUB_FILE_PAIR=($SUB_LINE)
					IFS="$OIFS"
					if [ $IGNORE_DEPLOYED -eq 0 ] && [[ $(git diff --name-status --no-renames $DEPLOYED_SHA1 $SYNCROOT -- "${SUB_FILE_PAIR[1]}" | grep '^D') ]]; then
						let DELETE_COUNT++
					else
						let MODIFY_COUNT++
					fi
				done

				if [ -f "${FILE_PAIR[0]}" ]; then
					if [ "$DELETE_COUNT" -gt 0 ] && [ "$MODIFY_COUNT" -eq 0 ]; then
						FILE_STATUS='D'
					else
						FILE_STATUS='M'
					fi
					echo "$FILE_STATUS	${FILE_PAIR[0]}" >> '.git-ftp-tmp'
				fi
			fi
		done
	fi

	# Filter against ignore file
	if [ -f '.git-ftp-ignore' ]; then
		grep -v '^#.*$\|^\s*$' '.git-ftp-ignore' | tr -d '\r' > '.git-ftp-ignore-tmp'
		FILES_CHANGED=$(grep --invert-match -f '.git-ftp-ignore-tmp' '.git-ftp-tmp' | tr '\t' ' ')
	else
		FILES_CHANGED=$(cat '.git-ftp-tmp' | tr '\t' ' ')
	fi

	rm -f '.git-ftp-tmp'
	rm -f '.git-ftp-tmp-files'
	rm -f '.git-ftp-include-tmp'
	rm -f '.git-ftp-ignore-tmp'

	if [ $IGNORE_DEPLOYED -ne 0 ]; then
		write_log "Sync all files."
		return
	fi

	if [ $git_diff_status -ne 0 ]; then
		if [ $FORCE -ne 1 ]; then
			print_info "Unknown SHA1 object, make sure you are deploying the right branch and it is up-to-date."
			echo -n "Do you want to ignore and upload all files again? [y/N]: "
			read ANSWER_STATE
			if [ "$ANSWER_STATE" != "y" ] && [ "$ANSWER_STATE" != "Y" ]; then
				print_info "Aborting..."
				exit 0
			else
				write_log "Taking all files.";
				FILES_CHANGED="$(git ls-files -t $SYNCROOT)"
			fi
		else
			print_info "Unknown SHA1 object, could not determine changed filed, taking all files."
			FILES_CHANGED="$(git ls-files -t $SYNCROOT)"
		fi
	elif [ -n "$FILES_CHANGED" ]; then
		write_log "Having changed files.";
	elif [ "$LOCAL_SHA1" != "$DEPLOYED_SHA1" ]; then
		write_log "No changed files, but different commit ID. Changed files ignored or commit amended.";
	else
		print_info "No changed files for $REMOTE_HOST/$REMOTE_PATH. Everything up-to-date."
		exit 0
	fi
}

handle_file_sync() {
        if [ -z "$FILES_CHANGED" ]; then
		print_info "There are no files to sync."
		return
        fi
	# Calculate total file count
	local DONE_ITEMS=0
	local TOTAL_ITEMS=$(echo "$FILES_CHANGED" | wc -l)
	TOTAL_ITEMS=$((TOTAL_ITEMS+0)) # trims whitespaces produced by wc
	print_info "There are $TOTAL_ITEMS files to sync:"

	# Changing internal field separator, file names could have spaces
	OIFS="$IFS"
	NIFS=$'\n'
	IFS="$NIFS"

	if [ $FORCE -eq 0 ] && [ $CHECK_FOR_REMOTE_CHANGES -eq 1 ]; then
		local FILES_CHANGED_FILTERED
		for FILE_ITERATOR in $FILES_CHANGED; do
			FILE_NAME=$(printf "$FILE_ITERATOR" | cut -f2- -d ' ')
			FILE_NAME=${FILE_NAME/#\"/}
			FILE_NAME=${FILE_NAME/%\"/}
			DEST_FILE=$(upload_get_dest_file $FILE_NAME)
			if remote_file_modified "$FILE_NAME" "$DEST_FILE" ; then
				if [ $INTERACTIVE -eq 0 ] ; then
					print_info ' ! [aborted]  Untracked remoted changes were found.'
					if [ "$ACTION" = 'init' ]; then
						print_info "Use 'git-ftp catchup' if your files are on the server already."
					else
						print_info "Merge the remote changes (e.g. 'git-ftp pull') before pushing again."
					fi
					print_info "You can disable this check with the parameter --ignore-remote-changes."
					release_remote_lock
					exit $ERROR_SYNC
				else
					if shall_overwrite_file "$FILE_NAME" "$DEST_FILE"; then
						FILES_CHANGED_FILTERED="$FILES_CHANGED_FILTERED$FILE_ITERATOR$IFS"
					fi
				fi
			else
				FILES_CHANGED_FILTERED="$FILES_CHANGED_FILTERED$FILE_ITERATOR$IFS"
			fi
		done
		FILES_CHANGED="$FILES_CHANGED_FILTERED"
	fi

	for FILE_ITERATOR in $FILES_CHANGED; do
		(( DONE_ITEMS++ ))
		FILE_MODE="$(echo "$FILE_ITERATOR" | cut -f1 -d ' ')"
		FILE_NAME="$(printf "$FILE_ITERATOR" | cut -f2- -d ' ')"
		FILE_NAME="${FILE_NAME/#\"/}"
		FILE_NAME="${FILE_NAME/%\"/}"

		if [ "$FILE_MODE" != "D" ]; then
			print_info "[$DONE_ITEMS of $TOTAL_ITEMS] Buffered for upload '$FILE_NAME'."

			if is_submodule "$FILE_NAME"; then
				handle_submodule_sync "${FILE_NAME#$SYNCROOT}"

			else
				if [ $DRY_RUN -ne 1 ]; then
					if is_arg_max_reached "$FILE_NAME" "${CURL_UPLOADS[@]}"; then
						IFS="$OIFS"
						fire_upload_buffer
						IFS="$NIFS"
					fi
					upload_file_buffered "$FILE_NAME" ""
				fi
			fi
		# Removing file
		else
			print_info "[$DONE_ITEMS of $TOTAL_ITEMS] Buffered for delete '$FILE_NAME'."

			if [ $DRY_RUN -ne 1 ]; then
				delete_file_buffered "${FILE_NAME#$SYNCROOT}" && delete_dir $(dirname "${FILE_NAME#$SYNCROOT}")
			fi
		fi
	done

	IFS="$OIFS"

	fire_upload_buffer

	fire_delete_buffer
}

handle_submodule_sync() {
	print_info "Handling submodule sync for $1."

	# Duplicate the current required parameters
	args=(--user "$REMOTE_USER" --passwd "$REMOTE_PASSWD")

	# Do not ask any questions for submodules
	args+=(--force)

	if [ $ACTIVE_MODE -eq 1 ]; then
		args+=(--active)
	else
		if [ $CURL_DISABLE_EPSV -eq 1 ]; then
			args+=(--disable-epsv)
		fi
	fi

	[ $IGNORE_DEPLOYED -eq 1 ] && args+=(--all)

	if [ $VERBOSE -eq 1 ]; then
		args+=(--verbose)
	elif [ $VERBOSE -eq -1 ]; then
		args+=(--silent)
	fi

	[ $DRY_RUN -eq 1 ] && args+=(--dry-run)

	(
		cd ${SYNCROOT}$1 && $0 $ACTION ${args[@]} $REMOTE_PROTOCOL://$REMOTE_HOST/${REMOTE_PATH}$1
	)

	local EXIT_CODE=$?

	# Pushing failed. Submodule may not be initialized
	if [ $EXIT_CODE -eq $ERROR_DOWNLOAD ] && [ "$ACTION" == "push" ]; then
		print_info "Could not push $1, trying to init..."
		(
			cd ${SYNCROOT}$1 && $0 init ${args[@]} $REMOTE_PROTOCOL://$REMOTE_HOST/${REMOTE_PATH}$1
		)
		check_exit_status "Failed to sync submodules." $ERROR_UPLOAD
	elif [ $EXIT_CODE -ne 0 ]; then
		print_error_and_die "Failed to sync submodules." $ERROR_UPLOAD
	fi
}

handle_remote_protocol_options() {
	if [ "$REMOTE_PROTOCOL" = "sftp" ]; then
		set_sftp_config
		
		if [ ! -z "$CURL_PRIVATE_KEY" ]; then
			write_log "Using ssh private key file $CURL_PRIVATE_KEY"
			if [ -z "$CURL_PUBLIC_KEY" ]; then
				# If public key is not specified, use private key with .pub extension
				CURL_PUBLIC_KEY="$CURL_PRIVATE_KEY.pub"
			fi
			write_log "Using ssh public key file $CURL_PUBLIC_KEY"
			REMOTE_CMD_OPTIONS="$REMOTE_CMD_OPTIONS --key $CURL_PRIVATE_KEY --pubkey $CURL_PUBLIC_KEY"
		fi
		
		# SFTP uses a different remove command and uses absolute paths
		REMOTE_DELETE_CMD="rm /"
	fi

	# Check for using cacert
	if [ "$REMOTE_PROTOCOL" = "ftpes" -o "$REMOTE_PROTOCOL" = "ftps" ] && \
	[ -n "$REMOTE_CACERT" -a -r "$REMOTE_CACERT" ]; then
		REMOTE_CMD_OPTIONS="$REMOTE_CMD_OPTIONS --cacert $REMOTE_CACERT"
	fi

	# Options for curl if using FTPES
	if [ "$REMOTE_PROTOCOL" = "ftpes" ]; then
		REMOTE_PROTOCOL="ftp"
		REMOTE_CMD_OPTIONS="$REMOTE_CMD_OPTIONS --ssl"
	fi

	# Require users' explicit consent for insecure connections
	[ "$CURL_INSECURE" != "0" ] && REMOTE_CMD_OPTIONS="$REMOTE_CMD_OPTIONS -k"
}

handle_action() {
	case "$ACTION" in
		init)
			action_init
			;;
		bootstrap)
			action_bootstrap
			;;
		push)
			action_push
			;;
		catchup)
			action_catchup
			;;
		show)
			action_show
			;;
		log)
			action_log
			;;
		download)
			action_download
			;;
		pull)
			action_pull
			;;
		add-scope)
			action_add_scope
			;;
		remove-scope)
			action_remove_scope
			;;
		*)
			print_error_and_die "Action unknown." $ERROR_MISSING_ARGUMENTS
			;;
	esac
}

set_remote_user() {
	[ -z $REMOTE_USER ] && REMOTE_USER="$(get_config user)"
}

set_remote_cacert() {
	[ -z $REMOTE_CACERT ] && REMOTE_CACERT="$(get_config cacert)"
}

set_remote_password() {
	[ -z "$REMOTE_PASSWD" ] && [ $USE_KEYCHAIN -eq 1 ] && get_keychain_password "$KEYCHAIN_USER"
	[ -z "$REMOTE_PASSWD" ] && REMOTE_PASSWD="$(get_config password)"
}

set_syncroot() {
	[ -z "$SYNCROOT" ] && SYNCROOT="$(get_config syncroot)"
	if [ "$SYNCROOT" ]; then
		[ -d "$SYNCROOT" ] || print_error_and_die "'$SYNCROOT' is not a directory! Exiting..." $ERROR_DEPENDENCY
		SYNCROOT=$(echo $SYNCROOT | sed 's#/*$##')/
	fi
}

set_sftp_config() {
	[ -z "$CURL_PRIVATE_KEY" ] && CURL_PRIVATE_KEY="$(get_config key)"
	[ -z "$CURL_PUBLIC_KEY" ] && CURL_PUBLIC_KEY="$(get_config pubkey)"
}

set_remotes() {
	set_remote_host
	write_log "Host is '$REMOTE_HOST'."

	set_remote_user
	write_log "User is '$REMOTE_USER'."

	set_remote_password
	if [ -z "$REMOTE_PASSWD" ]; then
		write_log "No password is set."
	else
		write_log "Password is set."
	fi 

	set_remote_protocol
	set_remote_path
	write_log "Path is '$REMOTE_PATH'."

	set_syncroot
	write_log "Syncroot is '$SYNCROOT'."

	set_remote_cacert
	write_log "CACert is '$REMOTE_CACERT'."
	
	set_curl_insecure
	write_log "Insecure is '$CURL_INSECURE'."
}

set_curl_insecure() {
	[ -z "$CURL_INSECURE" ] && CURL_INSECURE="$(get_config insecure)"
}

create_new_repo() {
	if [ -z "$NEW_REPO" ]; then
		if [ -n "$REMOTE_PATH" ]; then
			NEW_REPO=`basename ${REMOTE_PATH}`
		elif [ -n "$REMOTE_HOST" ]; then
			NEW_REPO=$REMOTE_HOST
		else
			print_error_and_die "Cannot bootstrap without a host, path, or directory to use. Exiting..." $ERROR_MISSING_ARGUMENTS
		fi
	fi
	[ -e $NEW_REPO ] && print_error_and_die "$NEW_REPO already exists. Exiting..." $ERROR_USAGE
	git init $NEW_REPO || print_error_and_die "git init $NEW_REPO failed. Exiting..."
}

get_protocol_of_url() {
	echo "$1" | tr '[:upper:]' '[:lower:]' | egrep '^(ftp|sftp|ftps|ftpes)://.*' | cut -d ':' -f 1
}

download_remote_updates () {
	write_log "Copying from ${REMOTE_HOST}/${REMOTE_PATH} $1"
        local mirror_options=''
	if [ "$DRY_RUN" = 1 ]; then
		mirror_options="$mirror_options --dry-run"
	fi
	if [ "$VERBOSE" -gt 0 ]; then
		mirror_options="$mirror_options -v"
	fi

	ignore=""
	if [ -f '.git-ftp-ignore' ]; then
		ignore=`grep -v ^# .git-ftp-ignore | awk 'NF' | sed 's/^/--exclude /'`
		ignore=`echo $ignore | tr -d '\r'`
	fi
	lftp $LFTP_OPTIONS -e "set ftp:list-options -a && mirror$mirror_options $ignore --delete --exclude=^\.git/ --exclude=^\.git-ftp\.log --exclude=^\.git-ftp-ignore . $SYNCROOT && wait all && exit" -u "${REMOTE_USER},${REMOTE_PASSWD}" ${REMOTE_PROTOCOL}://${REMOTE_HOST}/${REMOTE_PATH}
}

write_configs () {
	if [ -z "$SCOPE" ]; then
		git config git-ftp.user "$REMOTE_USER"
		git config git-ftp.password "$REMOTE_PASSWD"
		git config git-ftp.url "${REMOTE_PROTOCOL}://${REMOTE_HOST}/${REMOTE_PATH}"
	else
		git config git-ftp.$SCOPE.user "$REMOTE_USER"
		git config git-ftp.$SCOPE.password "$REMOTE_PASSWD"
		git config git-ftp.$SCOPE.url "${REMOTE_PROTOCOL}://${REMOTE_HOST}/${REMOTE_PATH}"
	fi
}

add_all_files_and_commit () {
	git add -A || print_error_and_die "git add -A failed. Exiting..."
	check_exit_status "'git add -A' failed" $ERROR_GIT
	if [ -n "$COMMIT_MESSAGE" ]; then
		git commit -m "$COMMIT_MESSAGE"
	else
		git commit
	fi
	check_exit_status "Skipping commit" $ERROR_GIT
}

cd_to_new_repo () {
	write_log "cd $NEW_REPO"
	cd $NEW_REPO || print_error_and_die "cd '$NEW_REPO' failed. Exiting..."
}

set_number_of_threads() {
	number_of_connections="$(get_config connections 2)"
}

set_scope() {
	[ -z $SCOPE ] && print_error_and_die "Missing scope argument." $ERROR_MISSING_ARGUMENTS
	[ -z $URL ] && print_error_and_die "Missing URL." $ERROR_MISSING_ARGUMENTS

	# URI without credentials
	if ! echo "$URL" | grep -q '@'; then
		$(git config git-ftp.$SCOPE.url $URL)
		return
	fi

	# set url
	local protocol=$(get_protocol_of_url "$URL")
	local path=${URL##*@}
	$(git config git-ftp.$SCOPE.url ${protocol}${path})

	# strip protocol
	local credentials=${URL#${protocol}}
	# cut at last '@' occurence
	local credentials=${credentials%${URL##*@}}
	# strip trailing '@'
	local credentials=${credentials%?}

	local colons=${credentials//[^:]/}
	case ${#colons} in
		0)
			# assume only username
			$(git config git-ftp.$SCOPE.user ${credentials})
			;;
		1)
			# credentials have both username and password
			$(git config git-ftp.$SCOPE.user ${credentials%:*})
			$(git config git-ftp.$SCOPE.password ${credentials#*:})
			;;
		*)
			# we can't know where to cut with multiple ':'
			print_info "Warning, multiple ':' characters detected, only URL was set in scope."
			print_info "Use --user and --passwd options to set login and password respectively."
	esac
}

remove_scope() {
	[ -z $SCOPE ] && print_error_and_die "Missing scope argument." $ERROR_MISSING_ARGUMENTS

	$(git config --remove-section git-ftp.$SCOPE &>/dev/null)

	[ $? -ne 0 ] && print_error_and_die "Cannot fine scope $SCOPE." $ERROR_GIT
	print_info "Successfully removed scope $SCOPE."
}

set_current_branch() {
	local current=$(git symbolic-ref --short HEAD)
	if [ "$?" -ne "0" ]; then
		set_local_sha1
		current=$LOCAL_SHA1
	fi
	write_log "currently on branch $current"
	CURRENT_BRANCH=$current
}

fetch_remote() {
	download_remote_updates
	git add --all
	git commit -m '[git-ftp] remotely untracked modifications'
	set_local_sha1
	upload_local_sha1
}

handle_fetch() {
	local old_sha1=$DEPLOYED_SHA1
	git checkout $DEPLOYED_SHA1 2> /dev/null
	remote_lock
	fetch_remote
	release_remote_lock
	git checkout $CURRENT_BRANCH 2> /dev/null
	print_info "From $REMOTE_HOST/$REMOTE_PATH"
	print_info "   $old_sha1..$LOCAL_SHA1"
}

# ------------------------------------------------------------
# Actions
# ------------------------------------------------------------
action_init() {
	check_git_version
	check_is_git_project
	check_is_dirty_repository
	set_remotes
	check_deployed_sha1
	set_local_sha1
	set_changed_files
	remote_lock
	handle_file_sync
	upload_local_sha1
	release_remote_lock
}

action_bootstrap() {
	check_git_version
	set_remotes
	create_new_repo
	cd_to_new_repo
	remote_lock
	download_remote_updates "into $NEW_REPO"
	write_configs
	add_all_files_and_commit
	upload_local_sha1
	release_remote_lock
}

action_push() {
	check_git_version
	check_is_git_project
	check_is_dirty_repository
	set_remotes
	set_deployed_sha1
	set_local_sha1
	set_changed_files
	remote_lock
	handle_file_sync
	upload_local_sha1
}

action_catchup() {
	check_is_git_project
	check_is_dirty_repository
	set_remotes
	set_local_sha1
	upload_local_sha1
}

action_show() {
	set_remotes
	DEPLOYED_SHA1="$(get_file_content $DEPLOYED_SHA1_FILE)"
	check_exit_status "Could not get uploaded log file" $ERROR_DOWNLOAD
	git show "$DEPLOYED_SHA1"
}

action_log() {
	set_remotes
	DEPLOYED_SHA1="$(get_file_content $DEPLOYED_SHA1_FILE)"
	check_exit_status "Could not get uploaded log file" $ERROR_DOWNLOAD
	git log "$DEPLOYED_SHA1"
}

action_download() {
	check_is_git_project
	check_is_dirty_repository
	check_lftp_available
	set_remotes
	remote_lock
	download_remote_updates
	release_remote_lock
}

action_pull() {
	check_is_git_project
	check_is_dirty_repository
	check_lftp_available
	set_current_branch
	set_remotes
	set_deployed_sha1
	handle_fetch
	git merge $MERGE_ARGS $LOCAL_SHA1
}

action_add_scope() {
	check_is_git_project
	set_scope
}

action_remove_scope() {
	check_is_git_project
	remove_scope
}
# ------------------------------------------------------------
# Checks
# ------------------------------------------------------------
check_deployed_sha1() {
	write_log "Check if $REMOTE_PROTOCOL://$REMOTE_HOST/$REMOTE_PATH is clean."
	DEPLOYED_SHA1="$(get_file_content $DEPLOYED_SHA1_FILE)"
	if [ "$DEPLOYED_SHA1" != "" ]; then
		print_error_and_die "Commit found, use 'git ftp push' to sync. Exiting..." $ERROR_USAGE
	fi
	# Make sure if sync all files if no sha1 was found
	IGNORE_DEPLOYED=1
}

check_git_version() {
	local GIT_VERSION=$(git --version | cut -d ' ' -f 3)
	local MAJOR=$(echo $GIT_VERSION | cut -d '.' -f 1)
	local MINOR=$(echo $GIT_VERSION | cut -d '.' -f 2)
	if [ $MAJOR -lt 2 ] && [ $MINOR -lt 7 ]; then
		print_error_and_die "Git is too old, 1.7.0 or higher supported only." $ERROR_GIT
	fi
}

check_remote_lock() {
	write_log "Checking remote lock."
	local LCK_CONTENT="$(get_file_content $REMOTE_LCK_FILE 2>/dev/null)"
	if [ -n "$LCK_CONTENT" ]; then
		local LCK_SHA1=$(echo "$LCK_CONTENT" | head -n 1)
		write_log "Remote lock sha1 $LCK_SHA1."
		write_log "Local sha1 $LOCAL_SHA1."
		if [ "$LCK_SHA1" != "$LOCAL_SHA1" ]; then
			local LCK_USER=$(echo "$LCK_CONTENT" | tail -n 1)
			print_error_and_die "Remote locked by $LCK_USER." $ERROR_REMOTE_LOCKED
		fi
	fi
}

check_is_git_project() {
	local git_project_dir="$(git rev-parse --show-toplevel 2>/dev/null)"
	[ -z "$git_project_dir" ] &&  print_error_and_die "Not a Git project? Exiting..." $ERROR_GIT
	cd "$git_project_dir"
}

check_is_dirty_repository() {
	[ $(git status -uno --porcelain | wc -l) -ne 0 ] && print_error_and_die "Dirty repository: Having uncommitted changes. Exiting..." $ERROR_GIT
}

check_lftp_available() {
	command -v lftp > /dev/null || print_error_and_die "lftp not found. This operation requires lftp installed." $ERROR_GIT
}

# ------------------------------------------------------------
# Main
# ------------------------------------------------------------
main() {
	cache_git_submodules
	handle_action
	print_error_log
	exit 0
}

# 2 args are needed: action and url
if [ $# = 0 ]; then
	usage;
fi

while test $# != 0
do
	case "$1" in
		init|bootstrap|push|catchup|show|download|pull|add-scope|remove-scope|log)
			ACTION="$1"
			# catch scope
			if [ "$1" == "add-scope" ] || [ "$1" == "remove-scope" ]; then
				SCOPE="$2"
				shift
			fi
			;;
		-h|--h|--he|--hel|--help|help)
			usage_long
			;;
		-u|--user*)
			case "$#,$1" in
				*,*=*)
					REMOTE_USER=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					REMOTE_USER="$USER"
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						REMOTE_USER="$2"
						shift
					else
						REMOTE_USER="$USER"
					fi
					;;
			esac
			;;
		-s|--scope*)
			case "$#,$1" in
				*,*=*)
					SCOPE=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					check_is_git_project && SCOPE=$(git branch | grep '*' | awk '{print $2}')
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						SCOPE="$2"
						shift
					else
						check_is_git_project && SCOPE=$(git branch | grep '*' | awk '{print $2}')
					fi
					;;
			esac
			set_deployed_sha1_file
			write_log "Using scope $SCOPE if available"
			;;
		--syncroot*)
			case "$#,$1" in
				*,*=*)
					SYNCROOT=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					print_error_and_die "Too few arguments for option --syncroot." $ERROR_MISSING_ARGUMENTS
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						SYNCROOT="$2"
						shift
					else
						print_error_and_die "Too few arguments for option --syncroot." $ERROR_MISSING_ARGUMENTS
					fi
					;;
			esac
			write_log "Using syncroot $SYNCROOT if exists."
			;;
		-c|--commit*)
			case "$#,$1" in
				*,*=*)
					DEPLOYED_SHA1=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					print_error_and_die "Too few arguments for option -c." $ERROR_MISSING_ARGUMENTS
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						DEPLOYED_SHA1="$2"
						shift
					else
						print_error_and_die "Too few arguments for option -c." $ERROR_MISSING_ARGUMENTS
					fi
					;;
			esac
			write_log "Using commit $DEPLOYED_SHA1 as deployed."
			;;
		-p|--passwd*)
			case "$#,$1" in
				*,*=*)
					REMOTE_PASSWD=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					ask_for_passwd
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						REMOTE_PASSWD="$2"
						shift
					else
						ask_for_passwd
					fi
					;;
			esac
			;;
		-k|--keychain*)
			USE_KEYCHAIN=1
			write_log "Enabled keychain."
			case "$#,$1" in
				*,*=*)
					KEYCHAIN_USER=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					# Nothing is handed over, this is okay
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						KEYCHAIN_USER="$2"
						shift
					fi
					;;
			esac
			;;
		-a|--all)
			IGNORE_DEPLOYED=1
			;;
		-l|--lock)
			if [ $ENABLE_REMOTE_LCK -ne 1 ]; then
				write_log "Enabling remote locking feature."
				ENABLE_REMOTE_LCK=1
			else
				write_log "Disabling remote locking feature."
				ENABLE_REMOTE_LCK=0
			fi
			;;
		-D|--dry-run)
			DRY_RUN=1
			write_log "Running dry, won't do anything."
			;;
		-n|--silent)
			VERBOSE=-1
			REMOTE_CMD_OPTIONS="-s"
			;;
		-v|--verbose)
			VERBOSE=1
			[ -n "$LOG_CACHE" ] && echo -e $LOG_CACHE
			REMOTE_CMD_OPTIONS=""
			;;
		-vv)
			VERBOSE=1
			[ -n "$LOG_CACHE" ] && echo -e $LOG_CACHE
			REMOTE_CMD_OPTIONS="-v"
			LFTP_OPTIONS="-d"
			;;
		-f|--force)
			FORCE=1
			write_log "Forced mode enabled."
			;;
		--version|version)
			echo "git-ftp version $VERSION"
			exit 0
			;;
		--insecure)
			CURL_INSECURE=1
			write_log "Insecure SSL/TLS connection allowed"
			;;
		--cacert*)
			case "$#,$1" in
				*,*=*)
					REMOTE_CACERT=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					print error_and_die "Too few arguments for option --cacert" $ERROR_MISSING_ARGUMENTS
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						REMOTE_CACERT="$2"
						shift
					else
						print_error_and_die "Too few arguments for option --cacert" $ERROR_MISSING_ARGUMENTS
					fi
					;;
			esac
			;;
		--key)
			case "$#,$1" in
				*,*=*)
					CURL_PRIVATE_KEY=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					print_error_and_die "Too few arguments for option --key." $ERROR_MISSING_ARGUMENTS
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						CURL_PRIVATE_KEY="$2"
						shift
					else
						print_error_and_die "Too few arguments for option --key." $ERROR_MISSING_ARGUMENTS
					fi
					;;
			esac
			;;
		--pubkey)
			case "$#,$1" in
				*,*=*)
					CURL_PUBLIC_KEY=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				1,*)
					print_error_and_die "Too few arguments for option --pubkey." $ERROR_MISSING_ARGUMENTS
					;;
				*)
					if ! echo "$2" | egrep -q '^-'; then
						CURL_PUBLIC_KEY="$2"
						shift
					else
						print_error_and_die "Too few arguments for option --pubkey." $ERROR_MISSING_ARGUMENTS
					fi
					;;
			esac
			;;
		-A|--active)
			ACTIVE_MODE=1
			write_log "Using active mode."
			;;
		--no-commit)
			MERGE_ARGS="$MERGE_ARGS --no-commit"
			write_log "Adding --no-commit to merge arguments: $MERGE_ARGS"
			;;
		--interactive)
			INTERACTIVE=1
			write_log "Asking if remote changes found."
			;;
		--ignore-remote-changes)
			CHECK_FOR_REMOTE_CHANGES=0
			write_log "Ignoring remote changes."
			;;
		--disable-epsv)
			if [ $ACTIVE_MODE -eq 0 ]; then
				CURL_DISABLE_EPSV=1
				write_log "Disabling EPSV."
					fi
					;;
		-m|--message)
			case "$#,$1" in
				*,*=*)
					COMMIT_MESSAGE=$(expr "z$1" : 'z-[^=]*=\(.*\)')
					;;
				*)
					if [ ! $(echo "$2" | egrep '^-' | wc -l) -eq 1 ]; then
						COMMIT_MESSAGE="$2"
						shift
					fi
					;;
			esac
			;;
		--connections)
			number_of_connections=$2
			shift
			;;
		--remote-root)
			REMOTE_ROOT="$2"
			shift
			;;
		*)
			# Pass thru anything that may be meant for download
			if [ "$ACTION" = "bootstrap" ] && [ -n "$URL" ]; then
				[ -n "$1" ] && NEW_REPO=$1
			else
				[ -n "$1" ] && URL=$1
			fi
			;;
	esac
	shift
done
main
